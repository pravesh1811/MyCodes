#include <iostream>

 

using namespace std;

 

    //I have declared many arrays(including Sudoku[][] and all rows,columns and blocks) as global, 
    //so as for them to retain their instantaneous values when used over and over again....

   

    int Sudoku[9][9] = {{5,3,0,0,7,0,0,0,0},{6,0,0,1,9,5,0,0,0},{0,9,8,0,0,0,0,6,0},
                        {8,0,0,0,6,0,0,0,3},{4,0,0,8,0,3,0,0,1},{7,0,0,0,2,0,0,0,6},
                        {0,6,0,0,0,0,2,8,0},{0,0,0,4,1,9,0,0,5},{0,0,0,0,8,0,0,7,9}};

    int column1[9];

    int column2[9];

    int column3[9];

    int column4[9];

    int column5[9];

    int column6[9];

    int column7[9];

    int column8[9];

    int column9[9];

   
    int row1[9];

    int row2[9];

    int row3[9];

    int row4[9];

    int row5[9];

    int row6[9];

    int row7[9];

    int row8[9];

    int row9[9];

   
    int block1[9];

    int block2[9];

    int block3[9];

    int block4[9];

    int block5[9];

    int block6[9];

    int block7[9];

    int block8[9];

    int block9[9];

   

    int VerticalStrip1[27];

    int VerticalStrip2[27];

    int VerticalStrip3[27];

   

    int HorizontalStrip1[27];

    int HorizontalStrip2[27];

    int HorizontalStrip3[27];

 

//int* WhichFound(int[]);

int ArrCount(int[]);//counts the no. of +ve nos(1 to 9) in an array

int* MaxCount(int []);//returns maximum no. from an array and also its index

int* Insert(int[]);//inserts the missing no. from 1 to 9 in an array

int Missingg[9];//global array to hold the missing values in a size 9 array(valus 1-9))

int* LeftOnes(int arr[]);//returns missing numbers in an array

int* Commonin3Arrays(int arr1[],int arr2[],int arr3[]);//returns the common elements in 3 arrays of size 9

int Common12[9];//global array to hold common values between arrays 1 and 2

int Common123[9];//global array to hold common values between arrays 1,2 and 3

void DisplaySudoku(int[][9]);

void UpdateSudoku(int[], int);

void UpdateCounts();

void UpdateStrips();

int Sudokutemp[9][9];

int sudokunonzerocount(int[][9]);

int* RemainingRowsColumnsinBlock(int,int);

int tempindex[4];

int index[4], commoninarr[9];
 

int main()

{

//   int *x,*p,*m;

    int *maxcount,*pointer;

 

    //The big array of all the 81 nos.

   

   

    int i=0,j=0,l=0,m=0;
    
    int *indexpointer;

    int maxcount_count;

    int maxcount_index;

 //   int maxcount;

   

   

   

//----------------Reading the Sudoku from the user---------------------------------


//Commenting the above for now until the code properly works for L1 Sudokus
//Since keying in all 81 inputs is cumbersome in the testing phase

/* 

    for(i=0;i<9;i++)

    {

        for(j=0;j<9;j++)

        {

            cin>>Sudoku[i][j];

        }

    }

*/  

//Hardcoding one sample Sudoku input(the one in iPhone Note) for testing purpose:
//Done above already


//----------------Coulmns Definition---------------------------------

 

    for(i=0;i<9;i++)

    {

        column1[i]=Sudoku[i][0];

    }

   

     for(i=0;i<9;i++)

    {

        column2[i]=Sudoku[i][1];

    }

   

     for(i=0;i<9;i++)

    {

        column3[i]=Sudoku[i][2];

    }

   

     for(i=0;i<9;i++)

    {

        column4[i]=Sudoku[i][3];

    }

   

     for(i=0;i<9;i++)

    {

        column5[i]=Sudoku[i][4];

    }

   

     for(i=0;i<9;i++)

    {

        column6[i]=Sudoku[i][5];

    }

   

     for(i=0;i<9;i++)

    {

        column7[i]=Sudoku[i][6];

    }

   

     for(i=0;i<9;i++)

    {

        column8[i]=Sudoku[i][7];

    }

   

    for(i=0;i<9;i++)

    {

        column9[i]=Sudoku[i][8];

    }

   

//----------------Rows Definition---------------------------------

 

     for(i=0;i<9;i++)

    {

        row1[i]=Sudoku[0][i];

    }

   

     for(i=0;i<9;i++)

    {

        row2[i]=Sudoku[1][i];

    }

   

     for(i=0;i<9;i++)

    {

        row3[i]=Sudoku[2][i];

    }

   

     for(i=0;i<9;i++)

    {

        row4[i]=Sudoku[3][i];

    }

   

     for(i=0;i<9;i++)

    {

        row5[i]=Sudoku[4][i];

    }

   

     for(i=0;i<9;i++)

    {

        row6[i]=Sudoku[5][i];

    }

   

     for(i=0;i<9;i++)

    {

        row7[i]=Sudoku[6][i];

    }

   

     for(i=0;i<9;i++)

    {

        row8[i]=Sudoku[7][i];

    }

   

    for(i=0;i<9;i++)

    {

        row9[i]=Sudoku[8][i];

    }

   

   

//----------------Blocks Definition---------------------------------

int k;

    k=0;

     for(i=0;i<3;i++)

    {

        for(j=0;j<3;j++)

        {

           block1[k]=Sudoku[i][j];

           k++;

        }

    }

   

    k=0;

     for(i=0;i<3;i++)

    {

        for(j=3;j<6;j++)

        {

            block2[k]=Sudoku[i][j];

            k++;

        }       

    }   

   

    k=0;

     for(i=0;i<3;i++)

    {

        for(j=6;j<9;j++)

        {

            block3[k]=Sudoku[i][j];

            k++;

        }       

    } 

   

    k=0;

     for(i=3;i<6;i++)

    {

        for(j=0;j<3;j++)

        {

            block4[k]=Sudoku[i][j];

            k++;

        }        

    } 

    

    k=0;

     for(i=3;i<6;i++)

    {

        for(j=3;j<6;j++)

        {

            block5[k]=Sudoku[i][j];

            k++;

        }       

    } 

   

    k=0;

     for(i=3;i<6;i++)

    {

        for(j=6;j<9;j++)

        {

            block6[k]=Sudoku[i][j];

            k++;

        }       

    } 

   

    k=0;   

     for(i=6;i<9;i++)

    {

        for(j=0;j<3;j++)

        {

            block7[k]=Sudoku[i][j];

            k++;

        }       

    } 

 

    k=0;   

     for(i=6;i<9;i++)

    {

        for(j=3;j<6;j++)

        {

            block8[k]=Sudoku[i][j];

            k++;

        }       

    }

   

    k=0;   

     for(i=6;i<9;i++)

    {

        for(j=6;j<9;j++)

        {

            block9[k]=Sudoku[i][j];

            k++;

        }       

    }

//Desi display of initial Sudoku(input from user):

cout<<"The original input Sudoku from user is:\n\n";

for (i=0;i<9;i++)
{
    for(j=0;j<9;j++)
    {
        cout<<Sudoku[i][j]<<" ";
    }
    cout<<"\n";
    cout<<"\n";
}

//testing:
//int *rowref1,*rowref2, *rowref3, rowref1arr[9], rowref2arr[9], rowref3arr[9], *commonin3, counter;

cout<<"\n";
cout<<"Initial sudokunonzerocount"<<sudokunonzerocount(Sudoku);
cout<<"\n";

int whilecount=0;

while(whilecount<=1)//(sudokunonzerocount(Sudoku)<1)//should run till all the cells in Sudoku are non zero or count is not 81
{

int totalloopcount=0;

//This is where we find the calculate empty cells of Sudoku which can be calculated through commonin3->Leftcount1 method

for (i=0;i<9;i++)
{
    int countleftout;
    
    for(j=0;j<9;j++)
    {
        int *rowref, *colref, *blockref, rowrefarr[9], colrefarr[9], blockrefarr[9], *commonin3;
        int counter, SudokuValue;
        
        totalloopcount++; 
        
        countleftout=0;//initializing here rather than inside if loop, so as to be safe
        
        if(Sudoku[i][j]==0)    //IMP: The first form of this Sudoku array should be the OG array entered by the user
        {
            //Finding the left ones in the row, column, block of this particular cell:
            
            //Left ones in the row:
            if(i==0)
            {
                rowref = LeftOnes(row1);
            }
            if(i==1)
            {
                rowref = LeftOnes(row2);
            }
            if(i==2)
            {
                rowref = LeftOnes(row3);
            }
            if(i==3)
            {
                rowref = LeftOnes(row4);
            }
            if(i==4)
            {
                rowref = LeftOnes(row5);
            }
            if(i==5)
            {
                rowref = LeftOnes(row6);
            }
            if(i==6)
            {
                rowref = LeftOnes(row7);
            }
            if(i==7)
            {
                rowref = LeftOnes(row8);
            }
            if(i==8)
            {
                rowref = LeftOnes(row9);
            }
            
            //Pointer returned from LeftOnes can't be parsed directly and used again.
            //Tested this(see the "Sudoku LeftOnesCommonin3 test" program for details)
            //Hence, again segregating it into array elements
            
            //assigning here only rather than after blockref, since that was overriding the row and col with block
            for(counter=0;counter<9;counter++)
            {
            rowrefarr[counter]=*(rowref+counter);
            //cout<<*(rowref+counter)<<" ";
            }
            
            //Left ones in the column:
            if(j==0)
            {
                colref = LeftOnes(column1);
            }
            if(j==1)
            {
                colref = LeftOnes(column2);
            }
            if(j==2)
            {
                colref = LeftOnes(column3);
            }
            if(j==3)
            {
                colref = LeftOnes(column4);
            }
            if(j==4)
            {
                colref = LeftOnes(column5);
            }
            if(j==5)
            {
                colref = LeftOnes(column6);
            }
            if(j==6)
            {
                colref = LeftOnes(column7);
            }
            if(j==7)
            {
                colref = LeftOnes(column8);
            }
            if(j==8)
            {
                colref = LeftOnes(column9);
            }
            
            //assigning here only rather than after blockref, since that was overriding the row and col with block
            for(counter=0;counter<9;counter++)
            {
            colrefarr[counter]=*(colref+counter);
            //cout<<*(colref+counter)<<" ";
            }
            
            //Left ones in block
            if(i<3 and j<3)
            {
                blockref = LeftOnes(block1);
            }
            if(i<3 and j>=3 and j<6 )
            {
                blockref = LeftOnes(block2);
            }
            if(i<3 and j>=6 and j<9)
            {
                blockref = LeftOnes(block3);
            }
            if(i>=3 and i<6 and j<3)
            {
                blockref = LeftOnes(block4);
            }
            if(i>=3 and i<6 and j>=3 and j<6)
            {
                blockref = LeftOnes(block5);
            }
            if(i>=3 and i<6 and j>=6 and j<9)
            {
                blockref = LeftOnes(block6);
            }
            if(i>=6 and i<9 and j<3)
            {
                blockref = LeftOnes(block7);
            }
            if(i>=6 and i<9 and j>=3 and j<6)
            {
                blockref = LeftOnes(block8);
            }
            if(i>=6 and i<9 and j>=6 and j<9)
            {
                blockref = LeftOnes(block9);
            }
            
            for(counter=0;counter<9;counter++)
            {
            blockrefarr[counter]=*(blockref+counter);
            //cout<<*(colref+counter)<<" ";
            }
            
            commonin3 = Commonin3Arrays(rowrefarr,colrefarr,blockrefarr);
            
            for(counter=0;counter<9;counter++)
            {
                cout<<"idhar dekh lo bhai\n";
                cout<<*(commonin3+counter)<<" ";
                if(*(commonin3+counter)!=0)
                {
                    SudokuValue = *(commonin3+counter);
                    countleftout++;
                }
            }
            
            if(countleftout==1)
            {
                Sudoku[i][j] = SudokuValue;
                j=0;
                break;
            }
            
        }//end of if
    }//end of j
    
        if(countleftout==1)
            {
                i=0;
            }
            
}//end of i

cout<<"The total loopcount is:\n\n"<<totalloopcount;

//**************************************|||||||||||||||||||||||||||||**********************************************

//This is where we calculate blank cells of Sudoku through commonin3->RemainingRowsColumnsinBlock method
//,those which couldn't be calculated in the above method

//Finding commonin3 array values(can be 2,3,4 any number of elements) in the Sudoku rows/columns with these indexes
//the entire code of Leftones and commonin3 goes here(except count logic)

for (i=0;i<9;i++)
{
    for(j=0;j<9;j++)
    {
        int *rowref, *colref, *blockref, rowrefarr[9], colrefarr[9], blockrefarr[9], *commonin3;
        int counter, SudokuValue;
        
        if(Sudoku[i][j]==0)    //IMP: The first form of this Sudoku array should be the OG array entered by the user
        {
            //Finding the left ones in the row, column, block of this particular cell:
            
            //Left ones in the row:
            if(i==0)
            {
                rowref = LeftOnes(row1);
            }
            if(i==1)
            {
                rowref = LeftOnes(row2);
            }
            if(i==2)
            {
                rowref = LeftOnes(row3);
            }
            if(i==3)
            {
                rowref = LeftOnes(row4);
            }
            if(i==4)
            {
                rowref = LeftOnes(row5);
            }
            if(i==5)
            {
                rowref = LeftOnes(row6);
            }
            if(i==6)
            {
                rowref = LeftOnes(row7);
            }
            if(i==7)
            {
                rowref = LeftOnes(row8);
            }
            if(i==8)
            {
                rowref = LeftOnes(row9);
            }
            
            //Pointer returned from LeftOnes can't be parsed directly and used again.
            //Tested this(see the "Sudoku LeftOnesCommonin3 test" program for details)
            //Hence, again segregating it into array elements
            
            //assigning here only rather than after blockref, since that was overriding the row and col with block
            for(counter=0;counter<9;counter++)
            {
            rowrefarr[counter]=*(rowref+counter);
            //cout<<*(rowref+counter)<<" ";
            }
            
            //Left ones in the column:
            if(j==0)
            {
                colref = LeftOnes(column1);
            }
            if(j==1)
            {
                colref = LeftOnes(column2);
            }
            if(j==2)
            {
                colref = LeftOnes(column3);
            }
            if(j==3)
            {
                colref = LeftOnes(column4);
            }
            if(j==4)
            {
                colref = LeftOnes(column5);
            }
            if(j==5)
            {
                colref = LeftOnes(column6);
            }
            if(j==6)
            {
                colref = LeftOnes(column7);
            }
            if(j==7)
            {
                colref = LeftOnes(column8);
            }
            if(j==8)
            {
                colref = LeftOnes(column9);
            }
            
            //assigning here only rather than after blockref, since that was overriding the row and col with block
            for(counter=0;counter<9;counter++)
            {
            colrefarr[counter]=*(colref+counter);
            //cout<<*(colref+counter)<<" ";
            }
            
            //Left ones in block
            if(i<3 and j<3)
            {
                blockref = LeftOnes(block1);
            }
            if(i<3 and j>=3 and j<6 )
            {
                blockref = LeftOnes(block2);
            }
            if(i<3 and j>=6 and j<9)
            {
                blockref = LeftOnes(block3);
            }
            if(i>=3 and i<6 and j<3)
            {
                blockref = LeftOnes(block4);
            }
            if(i>=3 and i<6 and j>=3 and j<6)
            {
                blockref = LeftOnes(block5);
            }
            if(i>=3 and i<6 and j>=6 and j<9)
            {
                blockref = LeftOnes(block6);
            }
            if(i>=6 and i<9 and j<3)
            {
                blockref = LeftOnes(block7);
            }
            if(i>=6 and i<9 and j>=3 and j<6)
            {
                blockref = LeftOnes(block8);
            }
            if(i>=6 and i<9 and j>=6 and j<9)
            {
                blockref = LeftOnes(block9);
            }
            
            for(counter=0;counter<9;counter++)
            {
            blockrefarr[counter]=*(blockref+counter);
            //cout<<*(colref+counter)<<" ";
            }
            
            commonin3 = Commonin3Arrays(rowrefarr,colrefarr,blockrefarr);
            
            for(counter=0;counter<9;counter++)
            {
                commoninarr[counter] = *(commonin3+counter);
            }
            
            //Determining the row and column index for the RemainingRowsColumnsinBlock

            indexpointer = RemainingRowsColumnsinBlock(i,j);
            
            for(k=0;k<4;k++)
            {
                index[k]=*(indexpointer+k);
                cout<<"k ye hai: "<<k;
                cout<<" index[k] ye hai: "<<index[k];
                cout<<"\n";
            }
            
            //Searching the commonin3 outputs in the 4 entities returned from RemainingRowsColumnsinBlock:
            int found;
            
            //checking for all non zero elements in commonin3 and then checking those in all 4 entities one by one.
            for(m=0;m<9;m++)
            {
                found=0;
                
                int arrrr[4] = {0,0,0,0};
                
                if(commoninarr[m]!=0)
                {
                   for(l=0;l<9;l++)
                    {
                    if(Sudoku[index[0]][l]==commoninarr[m])
                    {
                       found++; 
                       arrrr[0] = 1;
                    }
                    }
                    
                    for(l=0;l<9;l++)
                    {
                    if(Sudoku[index[1]][l]==commoninarr[m])
                    {
                       found++; 
                       arrrr[1] = 1;
                    }
                    }
                    
                    for(l=0;l<9;l++)
                    {
                    if(Sudoku[l][index[2]]==commoninarr[m])
                    {
                       found++; 
                       arrrr[2] = 1;
                    }
                    }
                    
                    for(l=0;l<9;l++)
                    {
                    if(Sudoku[l][index[3]]==commoninarr[m])
                    {
                       found++; 
                       arrrr[3] = 1;
                    }
                    }
                    
                    
                    if(found==4)
                    {
                       Sudoku[i][j] = commoninarr[m];
                    }
                    
                    if(found==3)
                    {
                       //Complex logic:
                       //There will be only two elements that don't come in intersection of the 3 elements. 
                       //One the cell which is to be filled and another one which is left. If the one left has some non zero
                       //value, only then conclusion can be drawn
                       if(arrrr[0]=0)
                       {
                           if(i%3==0 and Sudoku[i+1][j]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==1 and Sudoku[i-1][j]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==2 and Sudoku[i-2][j]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                       }
                       
                       if(arrrr[1]=0)
                       {
                           if(i%3==0 and Sudoku[i+2][j]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==1 and Sudoku[i+1][j]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==2 and Sudoku[i-1][j]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                       }
                       
                       if(arrrr[2]=0)
                       {
                           if(j%3==0 and Sudoku[i][j+1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(j%3==1 and Sudoku[i][j-1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(j%3==2 and Sudoku[i][j-2]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                       }
                      
                       if(arrrr[3]=0)
                       {
                           if(j%3==0 and Sudoku[i][j+2]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(j%3==1 and Sudoku[i][j+1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(j%3==2 and Sudoku[i][j-1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                       }
                       
                    }
                    
                    if(found==2)
                    {
                       //Complex logic:
                       //There will be either 3 or 4 elements that don't come in intersection of the 2 elements. 
                       //So either 2 or 3 of the remaining elements have to be non zero for conclusivity
                       
                       if(arrrr[0]==0 and arrrr[1]==0)//01....non intersecting
                       {
                           if(i%3==0 and Sudoku[i+1][j]!=0 and Sudoku[i+2][j]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==1 and Sudoku[i-1][j]!=0 and Sudoku[i+1][j]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==2 and Sudoku[i-2][j]!=0 and Sudoku[i-1][j]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                       }
                       
                       if(arrrr[0]==0 and arrrr[2]==0)//02....intersecting(very tricky.i%3 and j%3 both to be checked)
                       {
                           if(i%3==0 and j%3==0 and Sudoku[i+1][j]!=0 and Sudoku[i][j+1]!=0 and Sudoku[i+1][j+1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==0 and j%3==1 and Sudoku[i+1][j]!=0 and Sudoku[i][j-1]!=0 and Sudoku[i+1][j-1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==0 and j%3==2 and Sudoku[i+1][j]!=0 and Sudoku[i][j-2]!=0 and Sudoku[i+1][j-2]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==1 and j%3==0 and Sudoku[i][j+1]!=0 and Sudoku[i-1][j+1]!=0 and Sudoku[i-1][j]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==1 and j%3==1 and Sudoku[i][j-1]!=0 and Sudoku[i-1][j-1]!=0 and Sudoku[i-1][j]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==1 and j%3==2 and Sudoku[i][j-2]!=0 and Sudoku[i-1][j-2]!=0 and Sudoku[i-1][j]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==2 and j%3==0 and Sudoku[i][j+1]!=0 and Sudoku[i-2][j]!=0 and Sudoku[i-2][j+1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==2 and j%3==1 and Sudoku[i][j-1]!=0 and Sudoku[i-2][j]!=0 and Sudoku[i-2][j-1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==2 and j%3==2 and Sudoku[i][j-2]!=0 and Sudoku[i-2][j]!=0 and Sudoku[i-2][j-2]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                       }
                       
                       if(arrrr[0]==0 and arrrr[3]==0)//03....intersecting
                       {
                           if(i%3==0 and j%3==0 and Sudoku[i+1][j]!=0 and Sudoku[i][j+2]!=0 and Sudoku[i+1][j+2]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==0 and j%3==1 and Sudoku[i+1][j]!=0 and Sudoku[i][j+1]!=0 and Sudoku[i+1][j+1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==0 and j%3==2 and Sudoku[i+1][j]!=0 and Sudoku[i][j-1]!=0 and Sudoku[i+1][j-1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==1 and j%3==0 and Sudoku[i][j+2]!=0 and Sudoku[i-1][j+2]!=0 and Sudoku[i-1][j]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==1 and j%3==1 and Sudoku[i][j+1]!=0 and Sudoku[i-1][j+1]!=0 and Sudoku[i-1][j]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==1 and j%3==2 and Sudoku[i][j-2]!=0 and Sudoku[i-1][j-2]!=0 and Sudoku[i-1][j]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==2 and j%3==0 and Sudoku[i][j+1]!=0 and Sudoku[i-2][j]!=0 and Sudoku[i-2][j+1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==2 and j%3==1 and Sudoku[i][j-1]!=0 and Sudoku[i-2][j]!=0 and Sudoku[i-2][j-1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==2 and j%3==2 and Sudoku[i][j-2]!=0 and Sudoku[i-2][j]!=0 and Sudoku[i-2][j-2]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                       }
                      
                       if(arrrr[1]==0 and arrrr[2]==0)//12....intersecting
                       {
                           if(i%3==0 and j%3==0 and Sudoku[i][j+1]!=0 and Sudoku[i+2][j]!=0 and Sudoku[i+2][j+1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==0 and j%3==1 and Sudoku[i][j-1]!=0 and Sudoku[i+2][j]!=0 and Sudoku[i+2][j-1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==0 and j%3==2 and Sudoku[i][j-2]!=0 and Sudoku[i+2][j]!=0 and Sudoku[i+2][j-2]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==1 and j%3==0 and Sudoku[i][j+1]!=0 and Sudoku[i+1][j]!=0 and Sudoku[i+1][j+1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                          
                           if(i%3==1 and j%3==1 and Sudoku[i][j-1]!=0 and Sudoku[i+1][j]!=0 and Sudoku[i+1][j-1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==1 and j%3==2 and Sudoku[i][j-2]!=0 and Sudoku[i+1][j]!=0 and Sudoku[i+1][j-2]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==2 and j%3==0 and Sudoku[i][j+1]!=0 and Sudoku[i-1][j]!=0 and Sudoku[i-1][j+1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==2 and j%3==1 and Sudoku[i][j-1]!=0 and Sudoku[i-1][j]!=0 and Sudoku[i-1][j-1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==2 and j%3==2 and Sudoku[i][j-2]!=0 and Sudoku[i-1][j]!=0 and Sudoku[i-1][j-2]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                       }
                       
                       if(arrrr[1]==0 and arrrr[3]==0)//13....intersecting
                       {
                           if(i%3==0 and j%3==0 and Sudoku[i][j+2]!=0 and Sudoku[i+2][j]!=0 and Sudoku[i+2][j+2]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==0 and j%3==1 and Sudoku[i][j+1]!=0 and Sudoku[i+2][j]!=0 and Sudoku[i+2][j+1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==0 and j%3==2 and Sudoku[i][j-1]!=0 and Sudoku[i+2][j]!=0 and Sudoku[i+2][j-1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==1 and j%3==0 and Sudoku[i][j+2]!=0 and Sudoku[i+1][j]!=0 and Sudoku[i+1][j+2]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                          
                           if(i%3==1 and j%3==1 and Sudoku[i][j+1]!=0 and Sudoku[i+1][j]!=0 and Sudoku[i+1][j+1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==1 and j%3==2 and Sudoku[i][j-1]!=0 and Sudoku[i+1][j]!=0 and Sudoku[i+1][j-1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==2 and j%3==0 and Sudoku[i][j+2]!=0 and Sudoku[i-1][j]!=0 and Sudoku[i-1][j+2]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==2 and j%3==1 and Sudoku[i][j+1]!=0 and Sudoku[i-1][j]!=0 and Sudoku[i-1][j+1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==2 and j%3==2 and Sudoku[i][j-1]!=0 and Sudoku[i-1][j]!=0 and Sudoku[i-1][j-1]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                       }
                       
                       if(arrrr[2]==0 and arrrr[3]==0)//23....non intersecting
                       {
                           if(j%3==0 and Sudoku[i][j+1] and Sudoku[i][j+2])
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(j%3==1 and Sudoku[i][j-1] and Sudoku[i][j+1])
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(j%3==2 and Sudoku[i][j-2] and Sudoku[i][j-1])
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                       }
                    }//end of found == 2
                    
                     if(found==1)
                    {
                       if(arrrr[0]==0 and arrrr[1]==0 and arrrr[2]==0)//012
                       {
                           if(i%3==0 and j%3==0 and Sudoku[i][j+1]!=0 and Sudoku[i+1][j+1]!=0 and Sudoku[i+2][j+1]!=0
                           and Sudoku[i+1][j]!=0 and Sudoku[i+2][j]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==0 and j%3==1 and Sudoku[i][j-1]!=0 and Sudoku[i+1][j-1]!=0 and Sudoku[i+2][j-1]!=0
                           and Sudoku[i+1][j]!=0 and Sudoku[i+2][j]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                           
                           if(i%3==0 and j%3==2 and Sudoku[i][j-2]!=0 and Sudoku[i+1][j-2]!=0 and Sudoku[i+2][j-2]!=0
                           and Sudoku[i+1][j]!=0 and Sudoku[i+2][j]!=0)
                           {
                               Sudoku[i][j] = commoninarr[m];
                           }
                       }
                    }
                    
                }//end of if(commoninarr[m]!=0)
            }//end of m loop
            
        }//end of main if
    }//end of j
            
}//end of i

whilecount++;

}//end of while

/*
i=2;j=7;
indexpointer = RemainingRowsColumnsinBlock(i,j);

for(k=0;k<4;k++)
{
    index[k]=*(indexpointer+k);
    cout<<"k ye hai: "<<k;
    cout<<" index[k] ye hai: "<<index[k];
    cout<<"\n";
}*/

cout<<"\n";
cout<<"Final sudokunonzerocount"<<sudokunonzerocount(Sudoku);
cout<<"\n";

cout<<"The final Sudoku output to user is:\n\n";

for (i=0;i<9;i++)
{
    for(j=0;j<9;j++)
    {
        cout<<Sudoku[i][j]<<" ";
    }
    cout<<"\n";
    cout<<"\n";
}

// system("pause");

   return 0;

}
    
int* LeftOnes(int arr[])

    {

    int i;

    //Missingg[9]={1,2,3,4,5,6,7,8,9};
    //Not able to initialize like this....Need to check why this doesn't work

    for(i=0;i<9;i++)
    {
    Missingg[i]=i+1;  //Will hold the numbers that are missing in the size 9 array. It could be anything from 1 to 9
    }
 

    for(i=0;i<9;i++)

    {

        if(arr[i]==1)
        {
        Missingg[0]=0;
        }
        //break; I won't break the loop here, as we want all the missing numbers from the array
        if(arr[i]==2)
        {
        Missingg[1]=0;
        }
        if(arr[i]==3)
        {
        Missingg[2]=0;
        }
        if(arr[i]==4)
        {
        Missingg[3]=0;
        }
        if(arr[i]==5)
        {
        Missingg[4]=0;
        }
        if(arr[i]==6)
        {
        Missingg[5]=0;
        }
        if(arr[i]==7)
        {
        Missingg[6]=0;
        }
        if(arr[i]==8)
        {
        Missingg[7]=0;
        }
        if(arr[i]==9)
        {
        Missingg[8]=0;
        }
    }        

   return(Missingg);

}    
    
    
int* Commonin3Arrays(int arr1[],int arr2[],int arr3[])

{

    int i,j;
    
    int k;

    for(i=0;i<9;i++)
    {
        k=0;
        
        for(j=0;j<9;j++)
        {
           if((arr1[i]==arr2[j]) || (arr1[i]==0))
           {
              Common12[i] = arr1[i];
              k=1;
           }
        }
        
        if(k==0)
        {
            Common12[i] = 0;
        }
        
    }
    
    for(i=0;i<9;i++)
    {
        k=0;
        
        for(j=0;j<9;j++)
        {
           if((Common12[i]==arr3[j]) || (Common12[i]==0))
           {
              Common123[i] = Common12[i];
              k=1;
           }
        }
        
        if(k==0)
        {
            Common123[i] = 0;
        }
        
    }

   return(Common123);

}

int sudokunonzerocount(int Sudokutemp[][9])
{
    int counti;
    int countj;
    
    int tempsudokunonzerocount=0;
    
    for(counti=0;counti<9;counti++)
    {
        for(countj=0;countj<9;countj++)
        {
            if(Sudokutemp[counti][countj]!=0)
            {
                tempsudokunonzerocount++;
            }
        }
    }
    
    return(tempsudokunonzerocount);
    
}

int* RemainingRowsColumnsinBlock(int i,int j)
{
    //Initializing tempindex
    
    tempindex[0]=0;//row to check
    tempindex[1]=0;//row to check
    tempindex[2]=0;//column to check
    tempindex[3]=0;//column to check
    
    if(i%3==0 and j%3==0)
    {
        tempindex[0]=i+1;//row to check
        tempindex[1]=i+2;//row to check
        tempindex[2]=j+1;//column to check
        tempindex[3]=j+2;//column to check
    }
    
    if(i%3==0 and j%3==1)
    {
        tempindex[0]=i+1;//row to check
        tempindex[1]=i+2;//row to check
        tempindex[2]=j-1;//column to check
        tempindex[3]=j+1;//column to check
    }
    
    if(i%3==0 and j%3==2)
    {
        tempindex[0]=i+1;//row to check
        tempindex[1]=i+2;//row to check
        tempindex[2]=j-2;//column to check
        tempindex[3]=j-1;//column to check
    }
    
    if(i%3==1 and j%3==0)
    {
        tempindex[0]=i-1;//row to check
        tempindex[1]=i+1;//row to check
        tempindex[2]=j+1;//column to check
        tempindex[3]=j+2;//column to check
    }
    
    if(i%3==1 and j%3==1)
    {
        tempindex[0]=i-1;//row to check
        tempindex[1]=i+1;//row to check
        tempindex[2]=j-1;//column to check
        tempindex[3]=j+1;//column to check
    }
    
    if(i%3==1 and j%3==2)
    {
        tempindex[0]=i-1;//row to check
        tempindex[1]=i+1;//row to check
        tempindex[2]=j-2;//column to check
        tempindex[3]=j-1;//column to check
    }
    
    if(i%3==2 and j%3==0)
    {
        tempindex[0]=i-2;//row to check
        tempindex[1]=i-1;//row to check
        tempindex[2]=j+1;//column to check
        tempindex[3]=j+2;//column to check
    }
    
    if(i%3==2 and j%3==1)
    {
        tempindex[0]=i-2;//row to check
        tempindex[1]=i-1;//row to check
        tempindex[2]=j-1;//column to check
        tempindex[3]=j+1;//column to check
    }
    
    if(i%3==2 and j%3==2)
    {
        tempindex[0]=i-2;//row to check
        tempindex[1]=i-1;//row to check
        tempindex[2]=j-2;//column to check
        tempindex[3]=j-1;//column to check
    }
    
    return(tempindex);
}
